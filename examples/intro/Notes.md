# Notes

## What's an OS?
* Interface/bridge/glue between user apps & hardware
* Basis for application execution
* Resource manager

## Services of OS
* Process management
* Memory management
* File system management
* Storage management (disk)
* I/O management
* Network management
* Protection & security

* Actually all these services are provided by kernel through system calls.

## Computer Architecture (Recall)
* CPU, Memory, I/O Devices including storage
* CPU Registers
* CPU Cache - levels, private vs common, i-cache, d-cache etc.
* SMP Architecture
* Hyper threading
* Interrupt driven I/O vs Polling

## Dual mode operations of CPU
* supervisor mode vs normal mode
* mode bit
* transition to supervisor mode (trap instruction)
* some trap instructions, int 80h/sysenter in x86, swi/svc in ARM

## OS Architecture
* kernel
* drivers
* libraries
* system utils

## Kernel
* Core component of OS (essential component)
* Provides all kernel services
* Kernel resides in memory all the time


## Types of Kernel
* Monolithic kernel
* Micro kernel
* Cons and Pros of Monolithic, Micro kernel
* Modular kernel

## Linux is a modular kernel
* Collection of modules
* Static vs Dynamic modules
* Dynamic modules- load/unload at runtime
* Kernel image in Linux (/boot/vmlinuz*)
* Path of dynamic modules in Linux?

## Interrupts
* Asynchronous events
* Generated by I/O Devices, Timers, Hardware failures
* Interrupt Request, IRQ lines
* ISRs / Interrupt Handlers -- service the interrupts
* Interrupt Vector table
* CPU will execute ISR(service) with utmost priority
* ISRs should be as short as possible (execution time)
* No blocking calls inside interrupt
* Maskable vs Non Maskable interrupts
* Disabling interrupts only allowed in kernel mode, not recommended
  for longer time (inevitable during atomic operations)
* Non Maskable interrupts typically caused by critical failures.
* Context saving of preempted process when interrupt arrives
* What happens at end of ISR?

## System calls
* Interface between userspace and kernelspace
* Way of providing kernel services
* Also known as software interrrupts
* Defined and executed in kernel space
* Requested from userspace
* System call execution causes mode transition (trap)
* System calls are identified by unique number (not by address/name)

## Invoking system calls from userspace
* Identify system call number
* Save user mode context
* Store system call number in a register
* Store params in other general purpose registers
* Call the trap instruction
* Application Binary Interface(ABI)

## System call flow in kernel space
* Lookup ISR table with predefined offset
* Jump to common system call handler
* Retrieve system call no. from specific register
* Lookup system call table with calculated offset
* Jump to system call, as per address availale in sys call table
* Retrieve the parameters from registers
* Execute the system calls
* Return the result through designated register.

## System calls vs Library API
* Ease of use
* Portability
* Efficiency
